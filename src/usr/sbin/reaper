#!/usr/bin/env bash

set -e

function __cleanup ()
{
	__delete_lock
}

function __create_lock ()
{
	if [[ -n ${lock_file} ]]
	then
		touch "${lock_file}"
	fi
}

function __create_state ()
{
	if [[ -n ${state_file} ]]
	then
		printf -- \
			'%s %s\n' \
			"${session_start}" \
			"$(( ${session_start} + ${timeout} ))" \
			> "${state_file}"
	fi
}

function __delete_lock ()
{
	if [[ -e ${lock_file} ]]
	then
		rm -f "${lock_file}"
	fi
}

function __get_reaper_timeout ()
{
	local -r default_value="${1:-3600}"

	local value="${REAPER_TIMEOUT}"

	if ! __is_valid_reaper_timeout "${value}"
	then
		value="${default_value}"
	fi

	printf -- '%s' "${value}"
}

function __is_valid_get ()
{
	local -r get_options='^(end|start|ttl)$'
	local -r value="${1}"

	if [[ ${value} =~ ${get_options} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_positive_integer ()
{
	local -r positive_integer='^[0-9]+$'
	local -r value="${1}"

	if [[ ${value} =~ ${positive_integer} ]]
	then
		return 0
	fi

	return 1
}

function __is_valid_reaper_timeout ()
{
	__is_valid_positive_integer "${@}"
}

function __reap ()
{
	kill \
		-s "${signal:-TERM}" \
		"${pid:-1}"

	__cleanup
}

function main ()
{
	local -r lock_file="/var/lock/subsys/reaper"
	local -r state_file="/var/lib/misc/reaper"
	local -r timeout="$(
		__get_reaper_timeout
	)"

	local current_time
	local get
	local pid="1"
	local signal="TERM"
	local session_start
	local session_end
	local state_value
	local verbose="false"
	local warning_timeout="30"

	while [[ "${#}" -gt 0 ]]
	do
		case "${1}" in
			--get=*)
				get="${1#*=}"
				shift 1
				;;
			-g|--get)
				get="${2}"
				shift 2 || break
				;;
			--pid=*)
				pid="${1#*=}"
				shift 1
				;;
			-p|--pid)
				pid="${2}"
				shift 2 || break
				;;
			--signal=*)
				signal="${1#*=}"
				shift 1
				;;
			-s|--signal)
				signal="${2}"
				shift 2 || break
				;;
			-v|--verbose)
				verbose="true"
				shift 1
				;;
			*)
				>&2 printf -- \
					'ERROR: Unknown option %s\n' \
					"${1}"
				exit 1
				;;
		esac
	done

	if [[ -e ${lock_file} ]]
	then
		if [[ -n ${get} ]]
		then
			state_value="$(< "${state_file}")"

			session_end="${state_value##* }"
			session_start="${state_value%% *}"

			case "${get}" in
				end)
					printf -- \
						'%s\n' \
						"${session_end}"
					;;
				start)
					printf -- \
						'%s\n' \
						"${session_start}"
					;;
				ttl)
					current_time="$(
						date -u +%s
					)"

					printf -- \
						'%s\n' \
						"$(( ${session_end} - ${current_time} ))"
					;;
				*)
					>&2 printf -- \
						'ERROR: Unknown get value %s\n' \
						"${get}"
					exit 1
					;;
			esac

			exit 0
		else
			>&2 printf -- \
				'ERROR: %s lock detected - aborting\n' \
				"${0##*/}"
			exit 1
		fi
	fi

	trap __cleanup \
		EXIT INT TERM
	__create_lock

	if (( timeout > 0 ))
	then
		trap __reap \
			EXIT INT TERM

		if (( timeout <= warning_timeout ))
		then
			warning_timeout="0"
		fi

		session_start="$(
			date -u +%s
		)"

		__create_state

		if coproc read -t "$(( ${timeout} - ${warning_timeout} ))"
		then
			wait "${!}" || :

			if (( warning_timeout > 0 ))
			then
				wall "Session expires in ${warning_timeout} seconds." || :

				if coproc read -t "${warning_timeout}"
				then
					wait "${!}" || :
				fi
			else
				wall "Session expired." || :
			fi
		fi

		if [[ ${verbose} == true ]]
		then
			printf -- \
				'INFO: %s expiring session.\n' \
				"${0##*/}"
		fi
	fi

	exit 0
}

main "${@}"
